/*
 * Copyright 2024-2026 Firefly Software Solutions Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.fireflyframework.rules.core.dsl.compiler;

import org.fireflyframework.rules.core.dsl.ASTVisitor;
import org.fireflyframework.rules.core.dsl.action.*;
import org.fireflyframework.rules.core.dsl.condition.*;
import org.fireflyframework.rules.core.dsl.expression.*;
import org.fireflyframework.rules.core.dsl.model.ASTRulesDSL;
import org.fireflyframework.rules.core.services.ConstantService;
import org.fireflyframework.rules.interfaces.dtos.crud.ConstantDTO;
import org.fireflyframework.rules.interfaces.enums.ValueType;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.stream.Collectors;

/**
 * Complete Python code generator that compiles AST nodes to executable Python code.
 * This visitor traverses the entire AST and generates equivalent Python functions
 * that can be executed independently of the Java runtime.
 */
@Component
@Slf4j
public class PythonCodeGenerator implements ASTVisitor<String> {

    @Autowired
    private ConstantService constantService;

    private static final String PYTHON_RUNTIME_IMPORT = "from firefly_runtime import *";

    // Setter for testing purposes
    public void setConstantService(ConstantService constantService) {
        this.constantService = constantService;
    }
    private static final String CONTEXT_VAR = "context";
    private static final ThreadLocal<Integer> indentLevel = ThreadLocal.withInitial(() -> 0);

    /**
     * Generate complete Python code for a rule DSL
     */
    public String generatePythonFunction(ASTRulesDSL rule) {
        return generatePythonFunction(rule, null);
    }

    /**
     * Generate complete Python code for a rule DSL with custom function name
     */
    public String generatePythonFunction(ASTRulesDSL rule, String functionName) {
        log.info("Generating Python code for rule '{}'", rule.getName());

        // Reset indent level for thread safety
        indentLevel.set(0);

        StringBuilder code = new StringBuilder();

        // Add imports and setup
        code.append(generateHeader(rule));
        code.append("\n\n");

        // Generate main function
        code.append(generateMainFunction(rule, functionName));

        // Generate helper functions if needed
        code.append(generateHelperFunctions(rule));

        // Generate interactive main section
        code.append(generateInteractiveMain(rule, functionName));

        String pythonCode = code.toString();
        log.debug("Generated Python code:\n{}", pythonCode);

        return pythonCode;
    }

    private String generateHeader(ASTRulesDSL rule) {
        StringBuilder header = new StringBuilder();
        header.append("#!/usr/bin/env python3\n");
        header.append("# -*- coding: utf-8 -*-\n");
        header.append("#\n");
        header.append("# Copyright 2024-2026 Firefly Software Solutions Inc\n");
        header.append("#\n");
        header.append("# Licensed under the Apache License, Version 2.0 (the \"License\");\n");
        header.append("# you may not use this file except in compliance with the License.\n");
        header.append("# You may obtain a copy of the License at\n");
        header.append("#\n");
        header.append("#     http://www.apache.org/licenses/LICENSE-2.0\n");
        header.append("#\n");
        header.append("# Unless required by applicable law or agreed to in writing, software\n");
        header.append("# distributed under the License is distributed on an \"AS IS\" BASIS,\n");
        header.append("# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");
        header.append("# See the License for the specific language governing permissions and\n");
        header.append("# limitations under the License.\n");
        header.append("#\n");
        header.append("# Generated by Firefly Rule Engine Python Compiler\n");
        header.append("# Made with ❤️ by Firefly Software Solutions Inc\n");
        header.append("# Compilation Date: ").append(OffsetDateTime.now().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)).append("\n");
        header.append("#\n");
        header.append("# Rule: ").append(sanitizeComment(rule.getName())).append("\n");
        if (rule.getDescription() != null) {
            header.append("# Description: ").append(sanitizeComment(rule.getDescription())).append("\n");
        }
        if (rule.getVersion() != null) {
            header.append("# Version: ").append(rule.getVersion()).append("\n");
        }
        header.append("#\n");
        header.append("\n");
        header.append(PYTHON_RUNTIME_IMPORT).append("\n");
        return header.toString();
    }

    private String generateMainFunction(ASTRulesDSL rule) {
        return generateMainFunction(rule, null);
    }

    private String generateMainFunction(ASTRulesDSL rule, String functionName) {
        StringBuilder func = new StringBuilder();

        // Function signature
        String finalFunctionName = functionName != null ?
            sanitizeFunctionName(functionName) :
            sanitizeFunctionName(rule.getName());
        func.append("def ").append(finalFunctionName).append("(");
        func.append(CONTEXT_VAR).append("):\n");

        incrementIndent();

        // Function docstring
        func.append(indent()).append('\"').append('\"').append('\"').append("\n");
        func.append(indent()).append("Rule: ").append(rule.getName()).append("\n");
        if (rule.getDescription() != null) {
            func.append(indent()).append(rule.getDescription()).append("\n");
        }
        func.append(indent()).append("\n");
        func.append(indent()).append("Args:\n");
        func.append(indent()).append("    context (dict): Execution context with input variables\n");
        func.append(indent()).append("\n");
        func.append(indent()).append("Returns:\n");
        func.append(indent()).append("    dict: Output variables\n");
        func.append(indent()).append('\"').append('\"').append('\"').append("\n");

        // Initialize constants if any
        if (rule.getConstants() != null && !rule.getConstants().isEmpty()) {
            func.append(generateConstantsInitialization(rule.getConstants()));
        }

        // Generate rule logic
        if (rule.isSimpleSyntax()) {
            func.append(generateSimpleSyntaxLogic(rule));
        } else if (rule.getRules() != null && !rule.getRules().isEmpty()) {
            func.append(generateComplexRulesLogic(rule.getRules()));
        } else if (rule.getConditions() != null) {
            func.append(generateConditionalBlockLogic(rule.getConditions()));
        }

        // Return output
        func.append(generateReturnStatement(rule));

        decrementIndent();

        return func.toString();
    }

    private String generateSimpleSyntaxLogic(ASTRulesDSL rule) {
        StringBuilder logic = new StringBuilder();

        // Generate condition evaluation
        if (rule.getWhenConditions() != null && !rule.getWhenConditions().isEmpty()) {
            logic.append(indent()).append("# Evaluate conditions\n");
            logic.append(indent()).append("if ");

            String conditions = rule.getWhenConditions().stream()
                .map(condition -> condition.accept(this))
                .collect(Collectors.joining(" and "));

            logic.append(conditions).append(":\n");

            incrementIndent();

            // Generate then actions
            if (rule.getThenActions() != null && !rule.getThenActions().isEmpty()) {
                logic.append(indent()).append("# Then actions\n");
                for (Action action : rule.getThenActions()) {
                    logic.append(indent()).append(action.accept(this)).append("\n");
                }
            }

            decrementIndent();

            // Generate else actions if any
            if (rule.getElseActions() != null && !rule.getElseActions().isEmpty()) {
                logic.append(indent()).append("else:\n");
                incrementIndent();
                logic.append(indent()).append("# Else actions\n");
                for (Action action : rule.getElseActions()) {
                    logic.append(indent()).append(action.accept(this)).append("\n");
                }
                decrementIndent();
            }
        }

        return logic.toString();
    }

    private String generateComplexRulesLogic(List<ASTRulesDSL.ASTSubRule> rules) {
        StringBuilder logic = new StringBuilder();

        for (int i = 0; i < rules.size(); i++) {
            ASTRulesDSL.ASTSubRule subRule = rules.get(i);
            logic.append(indent()).append("# Sub-rule: ").append(subRule.getName() != null ? subRule.getName() : "Rule " + (i + 1)).append("\n");

            if (subRule.getWhenConditions() != null && !subRule.getWhenConditions().isEmpty()) {
                // Simple syntax sub-rule
                logic.append(generateSubRuleSimpleSyntax(subRule));
            } else if (subRule.getConditions() != null) {
                // Complex syntax sub-rule
                logic.append(generateSubRuleComplexSyntax(subRule));
            }

            if (i < rules.size() - 1) {
                logic.append("\n");
            }
        }

        return logic.toString();
    }

    private String generateSubRuleSimpleSyntax(ASTRulesDSL.ASTSubRule subRule) {
        StringBuilder logic = new StringBuilder();

        logic.append(indent()).append("if ");
        String conditions = subRule.getWhenConditions().stream()
            .map(condition -> condition.accept(this))
            .collect(Collectors.joining(" and "));
        logic.append(conditions).append(":\n");

        incrementIndent();
        if (subRule.getThenActions() != null && !subRule.getThenActions().isEmpty()) {
            for (Action action : subRule.getThenActions()) {
                logic.append(indent()).append(action.accept(this)).append("\n");
            }
        }
        decrementIndent();

        if (subRule.getElseActions() != null && !subRule.getElseActions().isEmpty()) {
            logic.append(indent()).append("else:\n");
            incrementIndent();
            for (Action action : subRule.getElseActions()) {
                logic.append(indent()).append(action.accept(this)).append("\n");
            }
            decrementIndent();
        }

        return logic.toString();
    }

    private String generateSubRuleComplexSyntax(ASTRulesDSL.ASTSubRule subRule) {
        return generateConditionalBlockLogic(subRule.getConditions());
    }

    private String generateConditionalBlockLogic(ASTRulesDSL.ASTConditionalBlock conditionalBlock) {
        StringBuilder logic = new StringBuilder();

        logic.append(indent()).append("if ").append(conditionalBlock.getIfCondition().accept(this)).append(":\n");

        incrementIndent();
        if (conditionalBlock.getThenBlock() != null) {
            logic.append(generateActionBlock(conditionalBlock.getThenBlock()));
        }
        decrementIndent();

        if (conditionalBlock.getElseBlock() != null) {
            logic.append(indent()).append("else:\n");
            incrementIndent();
            logic.append(generateActionBlock(conditionalBlock.getElseBlock()));
            decrementIndent();
        }

        return logic.toString();
    }

    private String generateActionBlock(ASTRulesDSL.ASTActionBlock actionBlock) {
        StringBuilder block = new StringBuilder();

        if (actionBlock.getActions() != null && !actionBlock.getActions().isEmpty()) {
            for (Action action : actionBlock.getActions()) {
                block.append(indent()).append(action.accept(this)).append("\n");
            }
        }

        if (actionBlock.getNestedConditions() != null) {
            block.append(generateConditionalBlockLogic(actionBlock.getNestedConditions()));
        }

        return block.toString();
    }

    private String generateConstantsInitialization(List<ASTRulesDSL.ASTConstantDefinition> constants) {
        StringBuilder init = new StringBuilder();

        init.append(indent()).append("# Initialize constants from database or default values\n");
        init.append(indent()).append("# NOTE: Constants marked as 'None' need to be configured in the database\n");
        init.append(indent()).append("#       or updated manually before execution\n");
        init.append(indent()).append("constants = {}\n");

        // Get constants from database
        Map<String, ConstantDTO> databaseConstants = new HashMap<>();
        if (constantService != null) {
            try {
                List<String> constantCodes = constants.stream()
                    .map(ASTRulesDSL.ASTConstantDefinition::getCode)
                    .collect(Collectors.toList());

                constantService.getConstantsByCodes(constantCodes)
                    .collectList()
                    .subscribeOn(reactor.core.scheduler.Schedulers.boundedElastic())
                    .block()
                    .forEach(dto -> databaseConstants.put(dto.getCode(), dto));
            } catch (Exception e) {
                log.warn("Failed to load constants from database: {}", e.getMessage());
            }
        }

        for (ASTRulesDSL.ASTConstantDefinition constant : constants) {
            init.append(indent()).append("constants['").append(constant.getCode()).append("'] = ");

            // Check if constant exists in database
            ConstantDTO dbConstant = databaseConstants.get(constant.getCode());
            if (dbConstant != null && dbConstant.getCurrentValue() != null) {
                // Use database value
                init.append(formatPythonValue(dbConstant.getCurrentValue()));
                init.append("  # From database");
            } else if (constant.getDefaultValue() != null) {
                // Use default value from DSL
                init.append(formatPythonValue(constant.getDefaultValue()));
                init.append("  # Default value");
            } else {
                // No value available - set to None with warning
                init.append("None");
                init.append("  # WARNING: Constant not found in database and no default value provided");
            }
            init.append("\n");
        }
        init.append("\n");

        return init.toString();
    }

    private String generateReturnStatement(ASTRulesDSL rule) {
        StringBuilder returnStmt = new StringBuilder();

        returnStmt.append("\n").append(indent()).append("# Return output variables\n");
        returnStmt.append(indent()).append("return {\n");

        incrementIndent();

        // Include explicitly defined outputs
        if (rule.getOutput() != null && !rule.getOutput().isEmpty()) {
            for (Map.Entry<String, String> output : rule.getOutput().entrySet()) {
                returnStmt.append(indent()).append("'").append(output.getKey()).append("': ");
                returnStmt.append(CONTEXT_VAR).append(".get('").append(output.getKey()).append("'),\n");
            }
        } else {
            // If no explicit outputs, include variables that are set in actions
            Set<String> setVariables = extractSetVariables(rule);
            for (String variable : setVariables) {
                returnStmt.append(indent()).append("'").append(variable).append("': ");
                returnStmt.append(CONTEXT_VAR).append(".get('").append(variable).append("'),\n");
            }
        }

        decrementIndent();

        returnStmt.append(indent()).append("}\n");

        return returnStmt.toString();
    }

    private String generateHelperFunctions(ASTRulesDSL rule) {
        // For now, return empty string. Helper functions can be added later if needed
        return "";
    }

    // Expression visitors
    @Override
    public String visitBinaryExpression(BinaryExpression node) {
        String left = node.getLeft().accept(this);
        String right = node.getRight().accept(this);
        String operator = mapBinaryOperatorToPython(node.getOperator());
        return String.format("(%s %s %s)", left, operator, right);
    }

    @Override
    public String visitUnaryExpression(UnaryExpression node) {
        String operand = node.getOperand().accept(this);
        String operator = mapUnaryOperatorToPython(node.getOperator());

        // Check if this is a function call (validation operators)
        if (operator.startsWith("firefly_")) {
            return String.format("%s(%s)", operator, operand);
        } else {
            return String.format("(%s %s)", operator, operand);
        }
    }

    @Override
    public String visitVariableExpression(VariableExpression node) {
        if (node.hasPropertyAccess()) {
            return String.format("get_nested_value(%s, '%s')", CONTEXT_VAR, node.getFullPath());
        } else if (node.hasIndexAccess()) {
            String indexExpr = node.getIndexExpression().accept(this);
            return String.format("get_indexed_value(%s, '%s', %s)", CONTEXT_VAR, node.getVariableName(), indexExpr);
        } else {
            // Check if this is a constant (UPPER_CASE_WITH_UNDERSCORES pattern)
            if (isConstantName(node.getVariableName())) {
                // Constants are accessed from the constants dictionary
                return String.format("constants.get('%s', None)", node.getVariableName());
            } else {
                // Regular variables are accessed from context
                String defaultValue = getDefaultValueForVariable(node.getVariableName());
                return String.format("%s.get('%s', %s)", CONTEXT_VAR, node.getVariableName(), defaultValue);
            }
        }
    }

    /**
     * Check if a variable name follows the constant naming convention (UPPER_CASE_WITH_UNDERSCORES)
     */
    private boolean isConstantName(String name) {
        return name != null && name.matches("^[A-Z][A-Z0-9_]*$");
    }

    private String getDefaultValueForVariable(String variableName) {
        // Common numeric variables get 0 as default
        if (variableName.toLowerCase().contains("score") ||
            variableName.toLowerCase().contains("amount") ||
            variableName.toLowerCase().contains("value") ||
            variableName.toLowerCase().contains("count") ||
            variableName.toLowerCase().contains("number") ||
            variableName.toLowerCase().contains("income") ||
            variableName.toLowerCase().contains("debt") ||
            variableName.toLowerCase().contains("age") ||
            variableName.toLowerCase().contains("price") ||
            variableName.toLowerCase().contains("cost") ||
            variableName.toLowerCase().contains("rate") ||
            variableName.toLowerCase().contains("percent")) {
            return "0";
        }
        // String variables get empty string
        return "''";
    }

    @Override
    public String visitLiteralExpression(LiteralExpression node) {
        return formatPythonValue(node.getValue());
    }

    @Override
    public String visitFunctionCallExpression(FunctionCallExpression node) {
        String functionName = mapFunctionToPython(node.getFunctionName());

        if (node.hasArguments()) {
            String args = node.getArguments().stream()
                .map(arg -> arg.accept(this))
                .collect(Collectors.joining(", "));
            return String.format("%s(%s)", functionName, args);
        } else {
            return String.format("%s()", functionName);
        }
    }

    @Override
    public String visitArithmeticExpression(ArithmeticExpression node) {
        // ArithmeticExpression is a complex expression with multiple operands
        String operation = node.getOperation().getName();
        List<String> operands = node.getOperands().stream()
            .map(operand -> operand.accept(this))
            .collect(Collectors.toList());

        return switch (operation.toLowerCase()) {
            case "sum" -> String.format("sum([%s])", String.join(", ", operands));
            case "average", "avg" -> String.format("statistics.mean([%s])", String.join(", ", operands));
            case "max" -> String.format("max(%s)", String.join(", ", operands));
            case "min" -> String.format("min(%s)", String.join(", ", operands));
            default -> String.format("firefly_%s(%s)", operation, String.join(", ", operands));
        };
    }

    @Override
    public String visitJsonPathExpression(JsonPathExpression node) {
        String sourceExpression = node.getSourceExpression().accept(this);
        String jsonPath = "\"" + node.getJsonPath() + "\"";
        return String.format("json_path_get(%s, %s)", sourceExpression, jsonPath);
    }

    @Override
    public String visitRestCallExpression(RestCallExpression node) {
        String method = "\"" + node.getHttpMethod() + "\"";
        String url = node.getUrlExpression().accept(this);

        StringBuilder restCall = new StringBuilder();
        restCall.append("rest_call(").append(method).append(", ").append(url);

        if (node.getBodyExpression() != null) {
            restCall.append(", ").append(node.getBodyExpression().accept(this));
        } else {
            restCall.append(", None");
        }

        if (node.getHeadersExpression() != null) {
            restCall.append(", ").append(node.getHeadersExpression().accept(this));
        } else {
            restCall.append(", None");
        }

        if (node.getTimeoutExpression() != null) {
            restCall.append(", ").append(node.getTimeoutExpression().accept(this));
        }

        restCall.append(")");
        return restCall.toString();
    }

    // Condition visitors
    @Override
    public String visitComparisonCondition(ComparisonCondition node) {
        String left = node.getLeft().accept(this);
        String operator = mapComparisonOperatorToPython(node.getOperator());
        String right = node.getRight().accept(this);

        // Handle special operators
        return switch (node.getOperator()) {
            case BETWEEN -> {
                String rangeEnd = node.getRangeEnd().accept(this);
                yield String.format("(%s <= %s <= %s)", right, left, rangeEnd);
            }
            case NOT_BETWEEN -> {
                String rangeEnd = node.getRangeEnd().accept(this);
                yield String.format("not (%s <= %s <= %s)", right, left, rangeEnd);
            }
            case IN, IN_LIST -> String.format("(%s in %s)", left, right);
            case NOT_IN, NOT_IN_LIST -> String.format("(%s not in %s)", left, right);
            case CONTAINS -> String.format("(%s in %s)", right, left);
            case NOT_CONTAINS -> String.format("(%s not in %s)", right, left);
            case STARTS_WITH -> String.format("%s.startswith(%s)", left, right);
            case ENDS_WITH -> String.format("%s.endswith(%s)", left, right);
            case MATCHES -> String.format("re.match(%s, %s) is not None", right, left);
            case NOT_MATCHES -> String.format("re.match(%s, %s) is None", right, left);
            case IS_NULL -> String.format("(%s is None)", left);
            case IS_NOT_NULL -> String.format("(%s is not None)", left);
            case IS_EMPTY -> String.format("firefly_is_empty(%s)", left);
            case IS_NOT_EMPTY -> String.format("firefly_is_not_empty(%s)", left);
            // Validation operators that are function calls
            case IS_POSITIVE -> String.format("firefly_is_positive(%s)", left);
            case IS_NEGATIVE -> String.format("firefly_is_negative(%s)", left);
            case IS_ZERO -> String.format("firefly_is_zero(%s)", left);
            case IS_NON_ZERO -> String.format("firefly_is_non_zero(%s)", left);
            case IS_NUMERIC -> String.format("firefly_is_numeric(%s)", left);
            case IS_NOT_NUMERIC -> String.format("firefly_is_not_numeric(%s)", left);
            case IS_EMAIL -> String.format("firefly_is_email(%s)", left);
            case IS_PHONE -> String.format("firefly_is_phone(%s)", left);
            case IS_DATE -> String.format("firefly_is_date(%s)", left);
            case IS_PERCENTAGE -> String.format("firefly_is_percentage(%s)", left);
            case IS_CURRENCY -> String.format("firefly_is_currency(%s)", left);
            case IS_CREDIT_SCORE -> String.format("firefly_is_valid_credit_score(%s)", left);
            case IS_SSN -> String.format("firefly_is_ssn(%s)", left);
            case IS_ACCOUNT_NUMBER -> String.format("firefly_is_account_number(%s)", left);
            case IS_ROUTING_NUMBER -> String.format("firefly_is_routing_number(%s)", left);
            case IS_BUSINESS_DAY -> String.format("firefly_is_business_day(%s)", left);
            case IS_WEEKEND -> String.format("firefly_is_weekend(%s)", left);
            default -> String.format("(%s %s %s)", left, operator, right);
        };
    }

    @Override
    public String visitLogicalCondition(LogicalCondition node) {
        List<String> operands = node.getOperands().stream()
            .map(operand -> operand.accept(this))
            .collect(Collectors.toList());

        return switch (node.getOperator()) {
            case AND -> String.format("(%s)", String.join(" and ", operands));
            case OR -> String.format("(%s)", String.join(" or ", operands));
            case NOT -> String.format("(not %s)", operands.get(0));
        };
    }

    @Override
    public String visitExpressionCondition(ExpressionCondition node) {
        return String.format("bool(%s)", node.getExpression().accept(this));
    }

    // Action visitors
    @Override
    public String visitAssignmentAction(AssignmentAction node) {
        String value = node.getValue().accept(this);
        String varName = sanitizeVariableName(node.getVariableName());

        return switch (node.getOperator()) {
            case ASSIGN -> String.format("%s['%s'] = %s", CONTEXT_VAR, varName, value);
            case ADD_ASSIGN -> String.format("%s['%s'] = %s.get('%s', 0) + %s",
                CONTEXT_VAR, varName, CONTEXT_VAR, varName, value);
            case SUBTRACT_ASSIGN -> String.format("%s['%s'] = %s.get('%s', 0) - %s",
                CONTEXT_VAR, varName, CONTEXT_VAR, varName, value);
            case MULTIPLY_ASSIGN -> String.format("%s['%s'] = %s.get('%s', 1) * %s",
                CONTEXT_VAR, varName, CONTEXT_VAR, varName, value);
            case DIVIDE_ASSIGN -> String.format("%s['%s'] = %s.get('%s', 1) / %s",
                CONTEXT_VAR, varName, CONTEXT_VAR, varName, value);
        };
    }

    @Override
    public String visitFunctionCallAction(FunctionCallAction node) {
        String functionName = mapFunctionToPython(node.getFunctionName());

        StringBuilder call = new StringBuilder();

        if (node.hasResultVariable()) {
            call.append(String.format("%s['%s'] = ", CONTEXT_VAR, node.getResultVariable()));
        }

        call.append(functionName).append("(");

        if (node.hasArguments()) {
            String args = node.getArguments().stream()
                .map(arg -> arg.accept(this))
                .collect(Collectors.joining(", "));
            call.append(args);
        }

        call.append(")");

        return call.toString();
    }

    @Override
    public String visitConditionalAction(ConditionalAction node) {
        StringBuilder conditional = new StringBuilder();

        conditional.append("if ").append(node.getCondition().accept(this)).append(":\n");

        incrementIndent();
        if (node.getThenActions() != null && !node.getThenActions().isEmpty()) {
            for (Action action : node.getThenActions()) {
                conditional.append(indent()).append(action.accept(this)).append("\n");
            }
        }
        decrementIndent();

        if (node.hasElseActions()) {
            conditional.append(indent()).append("else:\n");
            incrementIndent();
            for (Action action : node.getElseActions()) {
                conditional.append(indent()).append(action.accept(this)).append("\n");
            }
            decrementIndent();
        }

        return conditional.toString().trim();
    }

    @Override
    public String visitCalculateAction(CalculateAction node) {
        String expression = node.getExpression().accept(this);
        String resultVar = node.getResultVariable();
        return String.format("%s['%s'] = %s", CONTEXT_VAR, resultVar, expression);
    }

    @Override
    public String visitRunAction(RunAction node) {
        String expression = node.getExpression().accept(this);
        String resultVar = node.getResultVariable();
        return String.format("%s['%s'] = %s", CONTEXT_VAR, resultVar, expression);
    }

    @Override
    public String visitSetAction(SetAction node) {
        String value = node.getValue().accept(this);
        String varName = sanitizeVariableName(node.getVariableName());
        return String.format("%s['%s'] = %s", CONTEXT_VAR, varName, value);
    }

    @Override
    public String visitArithmeticAction(ArithmeticAction node) {
        String value = node.getValue().accept(this);
        String varName = node.getVariableName();

        return switch (node.getOperation()) {
            case ADD -> String.format("%s['%s'] = %s.get('%s', 0) + %s",
                CONTEXT_VAR, varName, CONTEXT_VAR, varName, value);
            case SUBTRACT -> String.format("%s['%s'] = %s.get('%s', 0) - %s",
                CONTEXT_VAR, varName, CONTEXT_VAR, varName, value);
            case MULTIPLY -> String.format("%s['%s'] = %s.get('%s', 1) * %s",
                CONTEXT_VAR, varName, CONTEXT_VAR, varName, value);
            case DIVIDE -> String.format("%s['%s'] = %s.get('%s', 1) / %s",
                CONTEXT_VAR, varName, CONTEXT_VAR, varName, value);
            default -> String.format("# Unsupported arithmetic operation: %s", node.getOperation());
        };
    }

    @Override
    public String visitListAction(ListAction node) {
        String value = node.getValue().accept(this);
        String listVar = node.getListVariable();

        return switch (node.getOperation()) {
            case APPEND -> String.format("%s.setdefault('%s', []).append(%s)",
                CONTEXT_VAR, listVar, value);
            case PREPEND -> String.format("%s.setdefault('%s', []).insert(0, %s)",
                CONTEXT_VAR, listVar, value);
            case REMOVE -> String.format("list_remove(%s.get('%s', []), %s)",
                CONTEXT_VAR, listVar, value);
        };
    }

    @Override
    public String visitCircuitBreakerAction(CircuitBreakerAction node) {
        String message = "\"" + node.getMessage() + "\"";
        String errorCode = node.getErrorCode() != null ? "\"" + node.getErrorCode() + "\"" : "None";
        return String.format("raise CircuitBreakerException(%s, %s)",
            message, errorCode);
    }

    @Override
    public String visitForEachAction(ForEachAction node) {
        StringBuilder code = new StringBuilder();
        String listExpr = node.getListExpression().accept(this);
        String iterVar = node.getIterationVariable();

        // Generate for loop
        if (node.hasIndexVariable()) {
            String indexVar = node.getIndexVariable();
            code.append(String.format("for %s, %s in enumerate(%s):\n", indexVar, iterVar, listExpr));
        } else {
            code.append(String.format("for %s in %s:\n", iterVar, listExpr));
        }

        // Indent and generate body actions
        incrementIndent();
        for (Action bodyAction : node.getBodyActions()) {
            code.append(indent()).append(bodyAction.accept(this)).append("\n");
        }
        decrementIndent();

        return code.toString();
    }

    @Override
    public String visitWhileAction(WhileAction node) {
        StringBuilder code = new StringBuilder();
        String condition = node.getCondition().accept(this);

        // Generate while loop with iteration limit
        code.append(String.format("_while_iterations = 0\n"));
        code.append(indent()).append(String.format("while %s and _while_iterations < %d:\n", condition, node.getMaxIterations()));

        // Indent and generate body actions
        incrementIndent();
        for (Action bodyAction : node.getBodyActions()) {
            code.append(indent()).append(bodyAction.accept(this)).append("\n");
        }
        code.append(indent()).append("_while_iterations += 1\n");
        decrementIndent();

        return code.toString();
    }

    @Override
    public String visitDoWhileAction(DoWhileAction node) {
        StringBuilder code = new StringBuilder();
        String condition = node.getCondition().accept(this);

        // Generate do-while loop (Python doesn't have do-while, so we use while True with break)
        code.append("_dowhile_iterations = 0\n");
        code.append(indent()).append("while True:\n");

        // Indent and generate body actions
        incrementIndent();
        for (Action bodyAction : node.getBodyActions()) {
            code.append(indent()).append(bodyAction.accept(this)).append("\n");
        }
        code.append(indent()).append("_dowhile_iterations += 1\n");
        code.append(indent()).append(String.format("if not (%s) or _dowhile_iterations >= %d:\n", condition, node.getMaxIterations()));
        incrementIndent();
        code.append(indent()).append("break\n");
        decrementIndent();
        decrementIndent();

        return code.toString();
    }

    // Utility methods
    private String indent() {
        return "    ".repeat(indentLevel.get());
    }

    private void incrementIndent() {
        indentLevel.set(indentLevel.get() + 1);
    }

    private void decrementIndent() {
        indentLevel.set(indentLevel.get() - 1);
    }

    private String sanitizeComment(String text) {
        if (text == null) return "";
        return text.replace("\n", " ").replace("\r", " ");
    }

    private String sanitizeVariableName(String name) {
        if (name == null || !name.matches("^[a-zA-Z_][a-zA-Z0-9_.]*$")) {
            throw new IllegalArgumentException("Invalid variable name for Python code generation: " + name);
        }
        return name;
    }

    public String sanitizeFunctionName(String name) {
        if (name == null) return "unnamed_rule";

        String sanitized = name.toLowerCase()
            .replaceAll("[^a-zA-Z0-9_]", "_")
            .replaceAll("_{2,}", "_")
            .replaceAll("^_|_$", "");

        // Add underscore prefix if starts with number
        if (sanitized.matches("^[0-9].*")) {
            sanitized = "_" + sanitized;
        }

        return sanitized;
    }

    private String formatPythonValue(Object value) {
        if (value == null) {
            return "None";
        } else if (value instanceof String) {
            String escaped = value.toString()
                .replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t")
                .replace("\0", "\\0");
            return "\"" + escaped + "\"";
        } else if (value instanceof Boolean) {
            return ((Boolean) value) ? "True" : "False";
        } else if (value instanceof List) {
            List<?> list = (List<?>) value;
            String elements = list.stream()
                .map(this::formatPythonValue)
                .collect(Collectors.joining(", "));
            return "[" + elements + "]";
        } else if (value instanceof Map) {
            Map<?, ?> map = (Map<?, ?>) value;
            String entries = map.entrySet().stream()
                .map(entry -> formatPythonValue(entry.getKey()) + ": " + formatPythonValue(entry.getValue()))
                .collect(Collectors.joining(", "));
            return "{" + entries + "}";
        } else {
            return value.toString();
        }
    }





    public List<String> extractInputVariables(ASTRulesDSL rule) {
        if (rule.getInput() != null) {
            return new ArrayList<>(rule.getInput().keySet());
        }
        return new ArrayList<>();
    }

    public Map<String, String> extractOutputVariables(ASTRulesDSL rule) {
        if (rule.getOutput() != null) {
            return rule.getOutput();
        }
        return new HashMap<>();
    }


    /**
     * Extract variables that are set in actions throughout the rule
     */
    private Set<String> extractSetVariables(ASTRulesDSL rule) {
        Set<String> setVariables = new HashSet<>();

        // Check simple syntax actions
        if (rule.getThenActions() != null) {
            setVariables.addAll(extractSetVariablesFromActions(rule.getThenActions()));
        }
        if (rule.getElseActions() != null) {
            setVariables.addAll(extractSetVariablesFromActions(rule.getElseActions()));
        }

        // Check complex syntax rules
        if (rule.getRules() != null) {
            for (ASTRulesDSL.ASTSubRule astRule : rule.getRules()) {
                if (astRule.getThenActions() != null) {
                    setVariables.addAll(extractSetVariablesFromActions(astRule.getThenActions()));
                }
                if (astRule.getElseActions() != null) {
                    setVariables.addAll(extractSetVariablesFromActions(astRule.getElseActions()));
                }
            }
        }

        return setVariables;
    }

    private Set<String> extractSetVariablesFromActions(List<Action> actions) {
        Set<String> setVariables = new HashSet<>();

        for (Action action : actions) {
            if (action instanceof SetAction) {
                SetAction setAction = (SetAction) action;
                setVariables.add(setAction.getVariableName());
            } else if (action instanceof CalculateAction) {
                CalculateAction calcAction = (CalculateAction) action;
                setVariables.add(calcAction.getResultVariable());
            } else if (action instanceof AssignmentAction) {
                AssignmentAction assignAction = (AssignmentAction) action;
                setVariables.add(assignAction.getVariableName());
            }
        }

        return setVariables;
    }
    private String mapBinaryOperatorToPython(BinaryOperator operator) {
        return switch (operator) {
            // Arithmetic operators
            case ADD -> "+";
            case SUBTRACT -> "-";
            case MULTIPLY -> "*";
            case DIVIDE -> "/";
            case MODULO -> "%";
            case POWER -> "**";

            // Comparison operators
            case EQUALS -> "==";
            case NOT_EQUALS -> "!=";
            case GREATER_THAN -> ">";
            case LESS_THAN -> "<";
            case GREATER_THAN_OR_EQUAL -> ">=";
            case LESS_THAN_OR_EQUAL -> "<=";
            case GREATER_EQUAL -> ">=";  // Alias
            case LESS_EQUAL -> "<=";     // Alias

            // String operators
            case CONTAINS -> " in ";
            case NOT_CONTAINS -> " not in ";
            case STARTS_WITH -> ".startswith";
            case ENDS_WITH -> ".endswith";
            case MATCHES -> "firefly_matches";
            case NOT_MATCHES -> "firefly_not_matches";

            // Logical operators
            case AND -> " and ";
            case OR -> " or ";

            // Special operators
            case BETWEEN -> "firefly_between";
            case NOT_BETWEEN -> "firefly_not_between";
            case IN -> " in ";
            case IN_LIST -> " in ";  // Alias
            case NOT_IN_LIST -> " not in ";

            // Age validation operators
            case AGE_AT_LEAST -> "firefly_age_at_least";
            case AGE_LESS_THAN -> "firefly_age_less_than";

            default -> throw new UnsupportedOperationException("Unsupported binary operator: " + operator);
        };
    }

    private String mapUnaryOperatorToPython(UnaryOperator operator) {
        return switch (operator) {
            // Arithmetic operators
            case NEGATE, MINUS -> "-";
            case POSITIVE, PLUS -> "+";

            // Logical operators
            case NOT -> "not ";

            // Existence operators
            case EXISTS -> "firefly_exists";
            case IS_NULL -> "firefly_is_null";
            case IS_NOT_NULL -> "firefly_is_not_null";

            // Type checking operators
            case IS_NUMBER -> "firefly_is_number";
            case IS_STRING -> "firefly_is_string";
            case IS_BOOLEAN -> "firefly_is_boolean";
            case IS_LIST -> "firefly_is_list";

            // String operators
            case TO_UPPER -> ".upper()";
            case TO_LOWER -> ".lower()";
            case TRIM -> ".strip()";
            case LENGTH -> "len";

            // Validation operators
            case IS_POSITIVE -> "firefly_is_positive";
            case IS_NEGATIVE -> "firefly_is_negative";
            case IS_ZERO -> "firefly_is_zero";
            case IS_EMPTY -> "firefly_is_empty";
            case IS_NOT_EMPTY -> "firefly_is_not_empty";
            case IS_NUMERIC -> "firefly_is_numeric";
            case IS_NOT_NUMERIC -> "firefly_is_not_numeric";
            case IS_EMAIL -> "firefly_is_email";
            case IS_PHONE -> "firefly_is_phone";
            case IS_DATE -> "firefly_is_date";
            case IS_PERCENTAGE -> "firefly_is_percentage";
            case IS_CURRENCY -> "firefly_is_currency";
            case IS_CREDIT_SCORE -> "firefly_is_valid_credit_score";
            case IS_SSN -> "firefly_is_ssn";
            case IS_ACCOUNT_NUMBER -> "firefly_is_account_number";
            case IS_ROUTING_NUMBER -> "firefly_is_routing_number";
            case IS_BUSINESS_DAY -> "firefly_is_business_day";
            case IS_WEEKEND -> "firefly_is_weekend";

            default -> throw new UnsupportedOperationException("Unsupported unary operator: " + operator);
        };
    }

    private String mapComparisonOperatorToPython(ComparisonOperator operator) {
        return switch (operator) {
            // Basic comparison operators
            case EQUALS -> "==";
            case NOT_EQUALS -> "!=";
            case LESS_THAN -> "<";
            case LESS_THAN_OR_EQUAL, LESS_EQUAL -> "<=";
            case GREATER_THAN -> ">";
            case GREATER_THAN_OR_EQUAL, GREATER_EQUAL -> ">=";

            // String operators
            case CONTAINS -> " in ";
            case NOT_CONTAINS -> " not in ";
            case STARTS_WITH -> ".startswith";
            case ENDS_WITH -> ".endswith";
            case MATCHES -> "firefly_matches";
            case NOT_MATCHES -> "firefly_not_matches";

            // Special operators
            case BETWEEN -> "firefly_between";
            case NOT_BETWEEN -> "firefly_not_between";
            case IN, IN_LIST -> " in ";
            case NOT_IN, NOT_IN_LIST -> " not in ";
            case EXISTS -> "firefly_exists";
            case NOT_EXISTS -> "firefly_not_exists";
            case IS_NULL -> "firefly_is_null";
            case IS_NOT_NULL -> "firefly_is_not_null";

            // Basic validation operators
            case IS_EMPTY -> "firefly_is_empty";
            case IS_NOT_EMPTY -> "firefly_is_not_empty";
            case IS_NUMERIC -> "firefly_is_numeric";
            case IS_NOT_NUMERIC -> "firefly_is_not_numeric";
            case IS_EMAIL -> "firefly_is_email";
            case IS_PHONE -> "firefly_is_phone";
            case IS_DATE -> "firefly_is_date";

            // Financial validation operators
            case IS_POSITIVE -> "firefly_is_positive";
            case IS_NEGATIVE -> "firefly_is_negative";
            case IS_ZERO -> "firefly_is_zero";
            case IS_NON_ZERO -> "firefly_is_non_zero";
            case IS_PERCENTAGE -> "firefly_is_percentage";
            case IS_CURRENCY -> "firefly_is_currency";
            case IS_CREDIT_SCORE -> "firefly_is_valid_credit_score";
            case IS_SSN -> "firefly_is_ssn";
            case IS_ACCOUNT_NUMBER -> "firefly_is_account_number";
            case IS_ROUTING_NUMBER -> "firefly_is_routing_number";

            // Date/time validation operators
            case IS_BUSINESS_DAY -> "firefly_is_business_day";
            case IS_WEEKEND -> "firefly_is_weekend";
            case AGE_AT_LEAST -> "firefly_age_at_least";
            case AGE_LESS_THAN -> "firefly_age_less_than";

            // Length operators
            case LENGTH_EQUALS -> "firefly_length_equals";
            case LENGTH_GREATER_THAN -> "firefly_length_greater_than";
            case LENGTH_LESS_THAN -> "firefly_length_less_than";

            default -> throw new UnsupportedOperationException("Unsupported comparison operator: " + operator);
        };
    }

    private String mapArithmeticOperationToPython(ArithmeticOperation operation) {
        return switch (operation) {
            // Basic arithmetic
            case ADD -> "+";
            case SUBTRACT -> "-";
            case MULTIPLY -> "*";
            case DIVIDE -> "/";
            case MODULO -> "%";
            case POWER -> "**";

            // Mathematical functions
            case ABS -> "abs";
            case MIN -> "min";
            case MAX -> "max";
            case ROUND -> "round";
            case FLOOR -> "math.floor";
            case CEIL -> "math.ceil";
            case SQRT -> "math.sqrt";
            case SUM -> "sum";
            case AVERAGE -> "firefly_average";

            default -> throw new UnsupportedOperationException("Unsupported arithmetic operation: " + operation);
        };
    }

    private String mapFunctionToPython(String functionName) {
        return switch (functionName.toLowerCase()) {
            // Built-in Python functions
            case "max" -> "max";
            case "min" -> "min";
            case "abs" -> "abs";
            case "round" -> "round";
            case "sum" -> "sum";
            case "len" -> "len";

            // Math functions
            case "ceil" -> "math.ceil";
            case "floor" -> "math.floor";
            case "sqrt" -> "math.sqrt";
            case "pow" -> "pow";

            // String functions
            case "upper" -> "str.upper";
            case "lower" -> "str.lower";
            case "substring" -> "firefly_substring";
            case "length" -> "len";
            case "trim" -> "str.strip";

            // Date functions
            case "now" -> "datetime.now";
            case "format_date" -> "firefly_format_date";
            case "calculate_age" -> "firefly_calculate_age";

            // Financial functions
            case "calculate_loan_payment" -> "firefly_calculate_loan_payment";
            case "calculate_compound_interest" -> "firefly_calculate_compound_interest";
            case "calculate_amortization" -> "firefly_calculate_amortization";
            case "debt_to_income_ratio" -> "firefly_debt_to_income_ratio";
            case "credit_utilization" -> "firefly_credit_utilization";
            case "loan_to_value" -> "firefly_loan_to_value";
            case "calculate_apr" -> "firefly_calculate_apr";
            case "calculate_credit_score" -> "firefly_calculate_credit_score";
            case "calculate_risk_score" -> "firefly_calculate_risk_score";
            case "payment_history_score" -> "firefly_payment_history_score";

            // Validation functions
            case "is_valid_credit_score" -> "firefly_is_valid_credit_score";
            case "is_valid_ssn" -> "firefly_is_valid_ssn";
            case "is_valid_account" -> "firefly_is_valid_account";
            case "is_valid_routing" -> "firefly_is_valid_routing";
            case "is_business_day" -> "firefly_is_business_day";
            case "age_meets_requirement" -> "firefly_age_meets_requirement";
            case "validate_email" -> "firefly_validate_email";
            case "validate_phone" -> "firefly_validate_phone";

            // Utility functions
            case "format_currency" -> "firefly_format_currency";
            case "format_percentage" -> "firefly_format_percentage";
            case "generate_account_number" -> "firefly_generate_account_number";
            case "generate_transaction_id" -> "firefly_generate_transaction_id";
            case "distance_between" -> "firefly_distance_between";
            case "is_valid" -> "firefly_is_valid";
            case "in_range" -> "firefly_in_range";

            // Logging/Auditing functions
            case "audit" -> "firefly_audit";
            case "audit_log" -> "firefly_audit_log";
            case "send_notification" -> "firefly_send_notification";
            case "log" -> "firefly_log";

            // Data Security functions
            case "encrypt" -> "firefly_encrypt";
            case "decrypt" -> "firefly_decrypt";
            case "mask_data" -> "firefly_mask_data";

            // REST API functions
            case "rest_get" -> "firefly_rest_get";
            case "rest_post" -> "firefly_rest_post";
            case "rest_put" -> "firefly_rest_put";
            case "rest_delete" -> "firefly_rest_delete";
            case "rest_patch" -> "firefly_rest_patch";
            case "rest_call" -> "firefly_rest_call";

            // JSON functions
            case "json_get", "json_path" -> "firefly_json_get";
            case "json_exists" -> "firefly_json_exists";
            case "json_size" -> "firefly_json_size";
            case "json_type" -> "firefly_json_type";

            // Default: prefix with firefly_
            default -> "firefly_" + functionName.toLowerCase();
        };
    }

    private String generateInteractiveMain(ASTRulesDSL rule, String functionName) {
        StringBuilder main = new StringBuilder();

        String finalFunctionName = functionName != null ?
            sanitizeFunctionName(functionName) :
            sanitizeFunctionName(rule.getName());

        main.append("\n\n");
        main.append("if __name__ == \"__main__\":\n");
        main.append("    \"\"\"\n");
        main.append("    Interactive execution mode for testing the compiled rule.\n");
        main.append("    \n");
        main.append("    Copyright 2024-2026 Firefly Software Solutions Inc\n");
        main.append("    Licensed under the Apache License, Version 2.0\n");
        main.append("    Made with ❤️ by Firefly Software Solutions Inc\n");
        main.append("    \"\"\"\n");
        main.append("    import sys\n");
        main.append("    import json\n");
        main.append("    \n");
        // Print header using runtime function
        main.append("    print_firefly_header(\"").append(rule.getName()).append("\"");
        if (rule.getDescription() != null) {
            main.append(", \"").append(rule.getDescription()).append("\"");
        } else {
            main.append(", None");
        }
        if (rule.getVersion() != null) {
            main.append(", \"").append(rule.getVersion()).append("\"");
        } else {
            main.append(", None");
        }
        main.append(")\n");
        main.append("    \n");

        // Check for constants that need configuration
        if (rule.getConstants() != null && !rule.getConstants().isEmpty()) {
            main.append("    # Check for constants that need configuration\n");
            main.append("    constants_need_config = []\n");
            for (ASTRulesDSL.ASTConstantDefinition constant : rule.getConstants()) {
                main.append("    if constants.get('").append(constant.getCode()).append("') is None:\n");
                main.append("        constants_need_config.append('").append(constant.getCode()).append("')\n");
            }
            main.append("    \n");
            main.append("    # Configure constants using runtime function\n");
            main.append("    constants_values = configure_constants_interactively(constants_need_config)\n");
            main.append("    constants.update(constants_values)\n");
            main.append("    \n");
        }

        // Interactive input collection
        main.append("    # Collect input variables\n");
        main.append("    context = {}\n");
        main.append("    \n");

        // Generate input definitions for the runtime
        if (rule.getInput() != null && !rule.getInput().isEmpty()) {
            main.append("    input_definitions = {\n");
            for (Map.Entry<String, String> input : rule.getInput().entrySet()) {
                String inputType = mapInputType(input.getValue());
                main.append("        '").append(input.getKey()).append("': '").append(inputType).append("',\n");
            }
            main.append("    }\n");
            main.append("    context = collect_inputs(input_definitions)\n");
        } else {
            main.append("    context = {}\n");
            main.append("    print(\"ℹ️  No input variables required for this rule.\")\n");
        }

        main.append("    \n");
        main.append("    print(\"\\n🚀 Executing rule...\")\n");
        main.append("    print(\"-\" * 40)\n");
        main.append("    \n");
        main.append("    try:\n");
        main.append("        # Execute the rule\n");
        main.append("        result = ").append(finalFunctionName).append("(context)\n");
        main.append("        print_execution_results(result)\n");
        main.append("    except Exception as e:\n");
        main.append("        print(f\"❌ Error executing rule: {e}\")\n");
        main.append("        import traceback\n");
        main.append("        traceback.print_exc()\n");
        main.append("        sys.exit(1)\n");
        main.append("    \n");
        main.append("    print_firefly_footer()\n");

        return main.toString();
    }



    /**
     * Map input type from DSL to Python helper function type
     */
    private String mapInputType(String dslType) {
        if (dslType == null) return "text";

        String lowerType = dslType.toLowerCase();
        if (lowerType.contains("number") || lowerType.contains("int") ||
            lowerType.contains("float") || lowerType.contains("decimal")) {
            return "number";
        } else if (lowerType.contains("bool")) {
            return "boolean";
        } else {
            return "text";
        }
    }


}
